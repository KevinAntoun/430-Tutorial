pipeline {
  agent any

  triggers {
    // poll every 2 minutes
    pollSCM('H/2 * * * *')
  }

  environment {
    NS            = 'default'
    APP           = 'mydjangoapp'
    DEPLOY        = 'django-deployment'   // metadata.name in deployment.yaml
    CTR           = 'django-container'    // containers[].name in deployment.yaml
    DOCKER_CTX    = 'ps2'                 // path containing Dockerfile
    MANIFEST_DIR  = 'ps2'                 // path containing deployment.yaml/service.yaml

    // Persist cluster config/state OUTSIDE the workspace (survives cleanWs and restarts)
    MK_ROOT       = '/var/jenkins_home/minikube/ps2'
    MINIKUBE_HOME = "${MK_ROOT}/.minikube"
    KUBECONFIG    = "${MK_ROOT}/.kube/config"

    // Dedicated Docker network for Minikube
    MK_DOCKER_NET = 'minikube-net'
    MK_SUBNET     = '10.123.0.0/16'

    // Running Minikube in a container
    MINIKUBE_IN_A_CONTAINER = 'true'
  }

  options {
    timestamps()
  }

  stages {

    stage('Checkout') {
      steps {
        cleanWs()
        git branch: 'main', url: 'https://github.com/KevinAntoun/430-Tutorial'
      }
    }

    stage('Install CLIs (once)') {
      steps {
        sh '''
          set -euo pipefail
          # Install necessary tools if they are not present
          if ! command -v minikube >/dev/null 2>&1; then
            curl -fsSL https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 -o /usr/local/bin/minikube
            chmod +x /usr/local/bin/minikube
          fi
          if ! command -v kubectl >/dev/null 2>&1; then
            KVER="$(curl -fsSL https://dl.k8s.io/release/stable.txt)"
            curl -fsSL "https://dl.k8s.io/release/${KVER}/bin/linux/amd64/kubectl" -o /usr/local/bin/kubectl
            chmod +x /usr/local/bin/kubectl
          fi
          if ! command -v socat >/dev/null 2>&1; then
            apt-get update -y && apt-get install -y --no-install-recommends socat
          fi

          # Ensure persistent dirs exist
          mkdir -p "${MINIKUBE_HOME}" "$(dirname "${KUBECONFIG}")"
        '''
      }
    }

    stage('Prepare dedicated Docker network for Minikube') {
      steps {
        sh '''
          set -euo pipefail
          if ! docker network inspect "${MK_DOCKER_NET}" >/dev/null 2>&1; then
            echo "Creating Docker network: ${MK_DOCKER_NET} (${MK_SUBNET})"
            docker network create --driver=bridge --subnet="${MK_SUBNET}" "${MK_DOCKER_NET}"
          fi
        '''
      }
    }

    stage('Start or Re-use Minikube (no destructive delete)') {
      steps {
        sh '''
          set -euo pipefail

          # --- Start the Robust Port Forwarding Bridge ---
          cat > /tmp/minikube_port_bridge.sh <<'EOSH'
#!/usr/bin/env bash
set -euo pipefail
declare -A BRIDGED_PORTS
while true; do
  PORT_MAPS=$(docker port minikube 2>/dev/null || true)
  if [[ -n "$PORT_MAPS" ]]; then
    while read -r line; do
      HOST_PORT=$(echo "$line" | awk -F: '{print $2}')
      if [[ -n "$HOST_PORT" && -z "${BRIDGED_PORTS[$HOST_PORT]:-}" ]]; then
        nohup socat TCP-LISTEN:${HOST_PORT},fork,reuseaddr TCP:host.docker.internal:${HOST_PORT} >/dev/null 2>&1 &
        BRIDGED_PORTS[$HOST_PORT]=true
        echo "[BRIDGE] Forwarding container localhost:${HOST_PORT} -> host.docker.internal:${HOST_PORT}"
      fi
    done <<< "$PORT_MAPS"
  fi
  sleep 2
done
EOSH
          chmod +x /tmp/minikube_port_bridge.sh
          nohup /tmp/minikube_port_bridge.sh >/tmp/port-bridge.log 2>&1 &
          sleep 2

          # --- Prefer reuse; start only if needed ---
          if minikube status -p minikube | grep -q "Running"; then
            echo "Reusing existing, running Minikube cluster."
            minikube -p minikube update-context
          else
            echo "Minikube not Running — attempting idempotent start (no delete)..."
            set +e
            minikube start -p minikube \
              --driver=docker \
              --container-runtime=containerd \
              --kubernetes-version=v1.30.0 \
              --cpus=2 --memory=4096 \
              --network="${MK_DOCKER_NET}" \
              --wait=all \
              --force \
              -v=3 --alsologtostderr
            rc=$?
            set -e

            if [ $rc -ne 0 ]; then
              echo "Start failed; cluster may be corrupted. Deleting profile and retrying a clean start..."
              # Delete the profile ONCE; DO NOT wipe the preload cache
              minikube delete -p minikube || true
              minikube start -p minikube \
                --driver=docker \
                --container-runtime=containerd \
                --kubernetes-version=v1.30.0 \
                --cpus=2 --memory=4096 \
                --network="${MK_DOCKER_NET}" \
                --wait=all \
                --force \
                -v=3 --alsologtostderr
            fi
          fi

          # Final verification to ensure the cluster is responsive
          echo "Verifying cluster connectivity..."
          kubectl config current-context
          kubectl get nodes -o wide
        '''
      }
    }

    stage('Compute Tag') {
      steps {
        script {
          env.TAG   = sh(returnStdout: true, script: 'git rev-parse --short HEAD').trim()
          env.IMAGE = "${env.APP}:${env.TAG}"
          echo "IMAGE=${env.IMAGE}"
        }
      }
    }

    stage('Build Docker Image (local)') {
      steps {
        dir(env.DOCKER_CTX) {
          sh 'docker build -t "${IMAGE}" .'
        }
      }
    }

    stage('Load Image into Minikube') {
      steps {
        sh 'minikube -p minikube image load "${IMAGE}"'
      }
    }

    stage('Apply Manifests & Rollout') {
      steps {
        sh """
          set -euo pipefail
          kubectl -n ${NS} apply -f ${MANIFEST_DIR}/deployment.yaml
          kubectl -n ${NS} apply -f ${MANIFEST_DIR}/service.yaml
          kubectl -n ${NS} set image deploy/${DEPLOY} ${CTR}=${IMAGE}
          kubectl -n ${NS} rollout status deploy/${DEPLOY} --timeout=180s
          kubectl -n ${NS} get deploy,pods,svc -o wide
        """
      }
    }

    // Optional: quick snapshot
    stage('Pods Snapshot & Debug') {
      steps {
        sh '''
          set -euo pipefail
          echo "== Context =="
          kubectl config current-context || true

          echo "== All namespaces =="
          kubectl get pods -A -o wide || true

          echo "== App namespace (${NS}) =="
          kubectl -n ${NS} get deploy,po,svc,ep -o wide || true

          # Dump details for non-ready pods
          not_ready=$(kubectl -n ${NS} get pods --no-headers | awk '$2 != "1/1" || $3 != "Running" {print $1}')
          if [ -n "${not_ready:-}" ]; then
            for p in $not_ready; do
              echo "---- describe $p ----"
              kubectl -n ${NS} describe pod "$p" || true
              echo "---- logs (all containers) $p ----"
              kubectl -n ${NS} logs --all-containers=true --prefix "$p" || true
            done
          fi
        '''
      }
    }

    // Install interactive wrapper scripts for later use
    stage('Make Interactive Access Easy') {
      steps {
        sh '''
          set -euo pipefail
          mkdir -p "${MINIKUBE_HOME}" "$(dirname "${KUBECONFIG}")"

          cat > /usr/local/bin/kube-ps2 <<'EOS'
#!/usr/bin/env bash
export MK_ROOT="/var/jenkins_home/minikube/ps2"
export MINIKUBE_HOME="${MK_ROOT}/.minikube"
export KUBECONFIG="${MK_ROOT}/.kube/config"
exec kubectl "$@"
EOS
          chmod +x /usr/local/bin/kube-ps2

          cat > /usr/local/bin/mk-ps2 <<'EOS'
#!/usr/bin/env bash
export MK_ROOT="/var/jenkins_home/minikube/ps2"
export MINIKUBE_HOME="${MK_ROOT}/.minikube"
export KUBECONFIG="${MK_ROOT}/.kube/config"
exec minikube -p minikube "$@"
EOS
          chmod +x /usr/local/bin/mk-ps2

          echo "Wrappers installed: kube-ps2, mk-ps2"
        '''
      }
    }

    // Optional: archive a small snapshot
    stage('Archive K8s Snapshot') {
      steps {
        sh '''
          set -euo pipefail
          mkdir -p k8s-dump
          kubectl config view --minify > k8s-dump/kubeconfig-view.txt || true
          kubectl -n ${NS} get deploy,po,rs,svc,ep -o wide > k8s-dump/resources.txt || true
          kubectl -n ${NS} get events --sort-by=.lastTimestamp > k8s-dump/events.txt || true
        '''
        archiveArtifacts artifacts: 'k8s-dump/**', allowEmptyArchive: true
      }
    }
  }

  post {
    always {
      echo 'Pipeline finished. Cleaning up port bridge...'
      sh 'pkill -f minikube_port_bridge.sh || true'
      sh 'pkill -f "socat TCP-LISTEN" || true'
    }
    failure {
      echo 'Collecting Minikube & network logs for debugging…'
      sh 'minikube -p minikube logs --file=logs.txt || true'
      archiveArtifacts artifacts: 'logs.txt', allowEmptyArchive: true
      sh 'docker network ls || true'
      sh 'docker network inspect "${MK_DOCKER_NET}" || true'
      sh 'echo "[BRIDGE LOGS]"; cat /tmp/port-bridge.log || true'
    }
  }
}
