pipeline {
  agent any

  triggers { pollSCM('H/2 * * * *') }

  environment {
    NS            = 'default'
    APP           = 'mydjangoapp'
    DEPLOY        = 'django-deployment'
    CTR           = 'django-container'
    DOCKER_CTX    = 'ps2'
    MANIFEST_DIR  = 'ps2'

    MK_ROOT       = '/var/jenkins_home/minikube/ps2'
    MINIKUBE_HOME = "${MK_ROOT}/.minikube"
    KUBECONFIG    = "${MK_ROOT}/.kube/config"

    MK_DOCKER_NET = 'minikube-net'
    MK_SUBNET     = '10.123.0.0/16'
    MINIKUBE_IN_A_CONTAINER = 'true'
  }

  options { timestamps() }

  stages {
    stage('Checkout') {
      steps {
        cleanWs()
        git branch: 'main', url: 'https://github.com/KevinAntoun/430-Tutorial'
      }
    }

    stage('Install CLIs (once)') {
      steps {
        sh '''
          set -euo pipefail
          if ! command -v minikube >/dev/null 2>&1; then
            curl -fsSL https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 -o /usr/local/bin/minikube
            chmod +x /usr/local/bin/minikube
          fi
          if ! command -v kubectl >/dev/null 2>&1; then
            KVER="$(curl -fsSL https://dl.k8s.io/release/stable.txt)"
            curl -fsSL "https://dl.k8s.io/release/${KVER}/bin/linux/amd64/kubectl" -o /usr/local/bin/kubectl
            chmod +x /usr/local/bin/kubectl
          fi
          apt-get update -y
          apt-get install -y --no-install-recommends iproute2 socat curl ca-certificates
          mkdir -p "${MINIKUBE_HOME}" "$(dirname "${KUBECONFIG}")"
        '''
      }
    }

    stage('Prepare dedicated Docker network for Minikube') {
      steps {
        sh '''
          set -euo pipefail
          if ! docker network inspect "${MK_DOCKER_NET}" >/dev/null 2>&1; then
            docker network create --driver=bridge --subnet="${MK_SUBNET}" "${MK_DOCKER_NET}"
          fi
        '''
      }
    }

    stage('Start or Re-use Minikube (race-free bridge, POSIX)') {
      steps {
        sh '''
          set -euo pipefail
          export NO_PROXY="127.0.0.1,localhost,.local,.svc,cluster.local,10.96.0.0/12,10.244.0.0/16,10.123.0.0/16"
          export no_proxy="${NO_PROXY}"
          unset HTTP_PROXY HTTPS_PROXY http_proxy https_proxy || true

          # --- background bridge loop (POSIX) ---
          cat > /tmp/minikube_port_bridge.sh <<'EOSH'
#!/usr/bin/env sh
set -eu
parse_host_port() { awk -F':' '{print $NF}'; }
while :; do
  PORT_MAPS="$(docker port minikube 2>/dev/null || true)"
  if [ -n "${PORT_MAPS}" ]; then
    echo "${PORT_MAPS}" | while IFS= read -r line; do
      [ -z "${line}" ] && continue
      HOST_PORT="$(echo "${line}" | parse_host_port)"
      case "${HOST_PORT}" in ''|*[!0-9]*) continue;; esac
      if ! ss -ltn 2>/dev/null | awk '{print $4}' | grep -q ":${HOST_PORT}\$"; then
        nohup socat TCP-LISTEN:${HOST_PORT},fork,reuseaddr TCP:host.docker.internal:${HOST_PORT} >/dev/null 2>&1 &
        echo "[BRIDGE] Forwarding container localhost:${HOST_PORT} -> host.docker.internal:${HOST_PORT}"
      fi
    done
  fi
  sleep 1
done
EOSH
          chmod +x /tmp/minikube_port_bridge.sh
          nohup /tmp/minikube_port_bridge.sh >/tmp/port-bridge.log 2>&1 &
          sleep 1

          # --- reuse or start cluster ---
          if minikube status -p minikube | grep -q Running; then
            echo "Reusing existing, running Minikube cluster."
            minikube -p minikube update-context
          else
            echo "Starting Minikube…"
            if ! minikube start -p minikube \
              --driver=docker \
              --container-runtime=containerd \
              --kubernetes-version=v1.30.0 \
              --cpus=2 --memory=4096 \
              --network="${MK_DOCKER_NET}" \
              --wait=all \
              --force \
              -v=3 --alsologtostderr; then
              echo "Start failed; deleting profile then retrying…"
              minikube delete -p minikube || true
              minikube start -p minikube \
                --driver=docker \
                --container-runtime=containerd \
                --kubernetes-version=v1.30.0 \
                --cpus=2 --memory=4096 \
                --network="${MK_DOCKER_NET}" \
                --wait=all \
                --force \
                -v=3 --alsologtostderr
            fi
          fi

          # --- explicit apiserver bridge + POSIX wait using socat as probe ---
          API_HOST_PORT="$(docker port minikube 8443/tcp | awk -F':' '{print $NF}' | tail -n1 || true)"
          case "${API_HOST_PORT}" in
            ''|*[!0-9]*) 
              echo "[APISERVER] Could not determine host port from 'docker port minikube 8443/tcp'"
              docker port minikube || true
              ;;
            *)
              echo "[APISERVER] Host port is ${API_HOST_PORT}"
              if ! ss -ltn 2>/dev/null | awk '{print $4}' | grep -q ":${API_HOST_PORT}\$"; then
                nohup socat TCP-LISTEN:${API_HOST_PORT},fork,reuseaddr TCP:host.docker.internal:${API_HOST_PORT} >/dev/null 2>&1 &
                echo "[APISERVER] Dedicated forward started on :${API_HOST_PORT}"
              fi

              printf "[APISERVER] Waiting for localhost:%s " "${API_HOST_PORT}"
              i=0
              while ! socat - TCP:127.0.0.1:${API_HOST_PORT},connect-timeout=1 </dev/null >/dev/null 2>&1; do
                i=$((i+1)); [ "${i}" -ge 90 ] && { echo "TIMEOUT"; tail -n 100 /tmp/port-bridge.log || true; exit 1; }
                printf "."
                sleep 1
              done
              echo "OK"
              ;;
          esac

          echo "Verifying cluster connectivity..."
          kubectl config current-context
          kubectl get nodes -o wide
        '''
      }
    }

    stage('Compute Tag') {
      steps {
        script {
          env.TAG   = sh(returnStdout: true, script: 'git rev-parse --short HEAD').trim()
          env.IMAGE = "${env.APP}:${env.TAG}"
          echo "IMAGE=${env.IMAGE}"
        }
      }
    }

    stage('Build Docker Image (local)') {
      steps {
        dir(env.DOCKER_CTX) {
          sh 'docker build -t "${IMAGE}" .'
        }
      }
    }

    stage('Load Image into Minikube') {
      steps { sh 'minikube -p minikube image load "${IMAGE}"' }
    }

    stage('Apply Manifests & Rollout') {
      steps {
        sh """
          set -euo pipefail
          kubectl -n ${NS} apply -f ${MANIFEST_DIR}/deployment.yaml
          kubectl -n ${NS} apply -f ${MANIFEST_DIR}/service.yaml
          # ensure the deployment uses the fresh image
          kubectl -n ${NS} set image deploy/${DEPLOY} ${CTR}=${IMAGE}
          kubectl -n ${NS} rollout status deploy/${DEPLOY} --timeout=180s
          kubectl -n ${NS} get deploy,pods,svc -o wide
        """
      }
    }

    stage('Pods Snapshot & Debug') {
      steps {
        sh '''
          set -euo pipefail
          echo "== Context =="; kubectl config current-context || true
          echo "== All namespaces =="; kubectl get pods -A -o wide || true
          echo "== App namespace (${NS}) =="; kubectl -n ${NS} get deploy,po,svc,ep -o wide || true

          not_ready="$(kubectl -n ${NS} get pods --no-headers | awk '$2 != "1/1" || $3 != "Running" {print $1}')"
          if [ -n "${not_ready}" ]; then
            for p in ${not_ready}; do
              echo "---- describe $p ----"
              kubectl -n ${NS} describe pod "$p" || true
              echo "---- logs (all containers) $p ----"
              kubectl -n ${NS} logs --all-containers=true --prefix "$p" || true
            done
          fi
        '''
      }
    }

    stage('Make Interactive Access Easy (wrappers + helpers)') {
      steps {
        sh '''
          set -euo pipefail
          mkdir -p "${MINIKUBE_HOME}" "$(dirname "${KUBECONFIG}")"

          # kube-ps2
          cat > /usr/local/bin/kube-ps2 <<'EOS'
#!/usr/bin/env sh
export MK_ROOT="/var/jenkins_home/minikube/ps2"
export MINIKUBE_HOME="${MK_ROOT}/.minikube"
export KUBECONFIG="${MK_ROOT}/.kube/config"
unset HTTP_PROXY HTTPS_PROXY http_proxy https_proxy
export NO_PROXY='127.0.0.1,localhost,.local,.svc,cluster.local,10.96.0.0/12,10.244.0.0/16,10.123.0.0/16'
export no_proxy="${NO_PROXY}"
exec kubectl "$@"
EOS
          chmod +x /usr/local/bin/kube-ps2

          # mk-ps2
          cat > /usr/local/bin/mk-ps2 <<'EOS'
#!/usr/bin/env sh
export MK_ROOT="/var/jenkins_home/minikube/ps2"
export MINIKUBE_HOME="${MK_ROOT}/.minikube"
export KUBECONFIG="${MK_ROOT}/.kube/config"
unset HTTP_PROXY HTTPS_PROXY http_proxy https_proxy
export NO_PROXY='127.0.0.1,localhost,.local,.svc,cluster.local,10.96.0.0/12,10.244.0.0/16,10.123.0.0/16'
export no_proxy="${NO_PROXY}"
exec minikube -p minikube "$@"
EOS
          chmod +x /usr/local/bin/mk-ps2

          # start-ps2-bridge
          cat > /usr/local/bin/start-ps2-bridge <<'EOS'
#!/usr/bin/env sh
set -eu
if ! pgrep -f minikube_port_bridge.sh >/dev/null 2>&1; then
  nohup /tmp/minikube_port_bridge.sh >/tmp/port-bridge.log 2>&1 &
fi
API_HOST_PORT="$(docker port minikube 8443/tcp | awk -F':' '{print $NF}' | tail -n1 || true)"
case "${API_HOST_PORT}" in
  ''|*[!0-9]*) echo "Could not determine API host port"; docker port minikube || true; exit 0 ;;
  *)
    if ! ss -ltn 2>/dev/null | awk '{print $4}' | grep -q ":${API_HOST_PORT}\$"; then
      nohup socat TCP-LISTEN:${API_HOST_PORT},fork,reuseaddr TCP:host.docker.internal:${API_HOST_PORT} >/dev/null 2>&1 &
    fi
    i=0; while ! socat - TCP:127.0.0.1:${API_HOST_PORT},connect-timeout=1 </dev/null >/dev/null 2>&1; do
      i=$((i+1)); [ "$i" -ge 60 ] && break; sleep 1
    done
    echo "Bridge ready on :${API_HOST_PORT}"
    ;;
esac
EOS
          chmod +x /usr/local/bin/start-ps2-bridge

          # stop-ps2-bridge
          cat > /usr/local/bin/stop-ps2-bridge <<'EOS'
#!/usr/bin/env sh
pkill -f minikube_port_bridge.sh >/dev/null 2>&1 || true
pkill -f "socat TCP-LISTEN" >/dev/null 2>&1 || true
echo "Bridge stopped"
EOS
          chmod +x /usr/local/bin/stop-ps2-bridge

          # expose-django-service (robust: tries tunnel URL, falls back to NodePort+minikube IP; verifies end-to-end)
          cat > /usr/local/bin/expose-django-service <<'EOS'
#!/usr/bin/env sh
set -eu
NS="${1:-default}"
SVC="${2:-django-service}"

unset HTTP_PROXY HTTPS_PROXY http_proxy https_proxy
export NO_PROXY='127.0.0.1,localhost,.local,.svc,cluster.local,10.96.0.0/12,10.244.0.0/16,10.123.0.0/16'
export no_proxy="${NO_PROXY}"

fail() { echo "ERROR: $*" >&2; exit 1; }

# Verify service exists
kube-ps2 -n "${NS}" get svc "${SVC}" >/dev/null 2>&1 || fail "Service ${NS}/${SVC} not found"

# Helper: publish a local port from Windows host to some target <HOST:PORT> reachable from publisher container
publish_and_verify() {
  HOST_LPORT="$1"        # desired host port (or empty for random)
  TARGET_HOST="$2"       # where the publisher should connect to
  TARGET_PORT="$3"       # target port
  NAME="$4"              # container name

  docker rm -f "${NAME}" >/dev/null 2>&1 || true

  PUB_ARG="-p 127.0.0.1:${HOST_LPORT}:${TARGET_PORT}"
  if [ -z "${HOST_LPORT}" ]; then
    PUB_ARG="-p 127.0.0.1::${TARGET_PORT}"
  fi

  # Run publisher on the 'bridge' network by default
  if docker run -d --name "${NAME}" --restart unless-stopped \
       --network bridge ${PUB_ARG} \
       alpine/socat \
       tcp-listen:${TARGET_PORT},fork,reuseaddr,bind=0.0.0.0 tcp:${TARGET_HOST}:${TARGET_PORT} >/dev/null 2>&1; then
    :
  else
    fail "Publisher container failed to start"
  fi

  # Determine the effective host port
  MAP="$(docker port "${NAME}" ${TARGET_PORT}/tcp | tail -n1 || true)"
  HOST_PORT="$(echo "${MAP}" | awk -F':' '{print $NF}')"
  [ -n "${HOST_PORT}" ] || fail "Could not determine published host port"

  # End-to-end verification from Windows perspective (via host.docker.internal)
  # If this probe fails, caller may fallback to an alternative method.
  if docker run --rm --network bridge alpine/curl \
       -sS --max-time 3 "http://host.docker.internal:${HOST_PORT}/" >/dev/null 2>&1; then
    echo "${HOST_PORT}"
    return 0
  fi
  echo "VERIFY: host.docker.internal:${HOST_PORT} not reachable; will fallback if possible"
  echo "${HOST_PORT}"
  return 1
}

# Method A: minikube service --url (tunnel to localhost in Jenkins)
URL_FILE="/tmp/${SVC}.url"; : > "${URL_FILE}"
pkill -f "minikube.*service.*${SVC}.*--url" >/dev/null 2>&1 || true
nohup mk-ps2 service -n "${NS}" "${SVC}" --url > "${URL_FILE}" 2>&1 &

printf "Starting minikube service --url for %s/%s " "${NS}" "${SVC}"
PORT=""; for i in $(seq 1 60); do
  LINE="$(grep -Eo 'http://127\\.0\\.0\\.1:[0-9]+' "${URL_FILE}" | head -n1 || true)"
  if [ -n "${LINE}" ]; then
    PORT="$(echo "${LINE}" | awk -F: '{print $3}')"
    echo "… OK (${LINE})"
    break
  fi
  printf "."; sleep 1
done
if [ -n "${PORT}" ]; then
  # Ensure listener inside Jenkins container
  pkill -f "socat TCP-LISTEN:${PORT}," >/dev/null 2>&1 || true
  nohup socat TCP-LISTEN:${PORT},fork,reuseaddr,bind=0.0.0.0 TCP:127.0.0.1:${PORT} >/dev/null 2>&1 &
  sleep 0.5

  # Publish to Windows (prefer same port)
  HOST_PORT="$(publish_and_verify "${PORT}" "$(hostname -I | awk '{print $1}')" "${PORT}" "expose-${SVC}-via-url" || true)"
  if [ -n "${HOST_PORT}" ] && docker ps --format '{{.Names}}' | grep -q "^expose-${SVC}-via-url$"; then
    echo "=== DIAG (Method A) ==="
    ss -ltn | grep ":${PORT}" || echo "No listener on :${PORT} inside Jenkins"
    docker port "expose-${SVC}-via-url" ${PORT}/tcp || true
    curl -sS --max-time 2 "http://127.0.0.1:${PORT}/" | head -n 2 || echo "[inner curl failed]"
    echo "minikube URL (inside Jenkins): http://127.0.0.1:${PORT}"
    echo "Open on Windows: http://127.0.0.1:${HOST_PORT}"
    exit 0
  fi
  echo "Method A publishing failed verification; trying Method B…"
fi

# Method B: NodePort directly via minikube container IP (connect publisher to minikube-net)
NODE_PORT="$(kube-ps2 -n "${NS}" get svc "${SVC}" -o jsonpath='{.spec.ports[0].nodePort}')"
[ -n "${NODE_PORT}" ] || fail "Could not determine NodePort"
MINIKUBE_IP="$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' minikube 2>/dev/null || true)"
[ -n "${MINIKUBE_IP}" ] || fail "Could not determine minikube container IP"

# Run publisher on the SAME network as minikube to reach its IP, while still publishing to Windows
NAME="expose-${SVC}-via-nodeport"
docker rm -f "${NAME}" >/dev/null 2>&1 || true
if docker run -d --name "${NAME}" --restart unless-stopped \
     --network "${MK_DOCKER_NET:-minikube-net}" \
     -p 127.0.0.1:${NODE_PORT}:${NODE_PORT} \
     alpine/socat \
     tcp-listen:${NODE_PORT},fork,reuseaddr,bind=0.0.0.0 tcp:${MINIKUBE_IP}:${NODE_PORT} >/dev/null 2>&1; then
  :
else
  fail "Publisher (NodePort) failed to start"
fi

MAP="$(docker port "${NAME}" ${NODE_PORT}/tcp | tail -n1 || true)"
HOST_PORT="$(echo "${MAP}" | awk -F':' '{print $NF}')"
[ -n "${HOST_PORT}" ] || fail "Could not determine published host port (NodePort)"

# Verify from host viewpoint
if docker run --rm --network bridge alpine/curl \
     -sS --max-time 5 "http://host.docker.internal:${HOST_PORT}/" >/dev/null 2>&1; then
  echo "=== DIAG (Method B) ==="
  docker port "${NAME}" ${NODE_PORT}/tcp || true
  echo "NodePort target: ${MINIKUBE_IP}:${NODE_PORT}"
  echo "Open on Windows: http://127.0.0.1:${HOST_PORT}"
  exit 0
fi

echo "Verification failed for both methods."
echo "Try manually from Windows: http://127.0.0.1:${HOST_PORT}"
exit 1
EOS
          chmod +x /usr/local/bin/expose-django-service

          echo "Installed: kube-ps2, mk-ps2, start-ps2-bridge, stop-ps2-bridge, expose-django-service"
        '''
      }
    }

    // Optional: print the Windows-friendly URL
    stage('Expose Django URL (print for Windows)') {
      steps {
        sh '''
          set -euo pipefail
          start-ps2-bridge
          echo "Discovering a Windows-friendly URL for django-service..."
          expose-django-service default django-service || true
        '''
      }
    }

    stage('Archive K8s Snapshot') {
      steps {
        sh '''
          set -euo pipefail
          mkdir -p k8s-dump
          kubectl config view --minify > k8s-dump/kubeconfig-view.txt || true
          kubectl -n ${NS} get deploy,po,rs,svc,ep -o wide > k8s-dump/resources.txt || true
          kubectl -n ${NS} get events --sort-by=.lastTimestamp > k8s-dump/events.txt || true
        '''
        archiveArtifacts artifacts: 'k8s-dump/**', allowEmptyArchive: true
      }
    }
  }

  post {
    always {
      echo 'Pipeline finished.'
    }
    failure {
      echo 'Collecting Minikube & network logs for debugging…'
      sh 'minikube -p minikube logs --file=logs.txt || true'
      archiveArtifacts artifacts: 'logs.txt', allowEmptyArchive: true
      sh 'docker network ls || true'
      sh 'docker network inspect "${MK_DOCKER_NET}" || true'
      sh 'echo "[BRIDGE LOGS]"; tail -n 200 /tmp/port-bridge.log || true'
    }
  }
}
