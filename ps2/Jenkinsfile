pipeline {
  agent any

  triggers { pollSCM('H/2 * * * *') }

  environment {
    NS            = 'default'
    APP           = 'mydjangoapp'
    DEPLOY        = 'django-deployment'
    CTR           = 'django-container'
    DOCKER_CTX    = 'ps2'
    MANIFEST_DIR  = 'ps2'

    MK_ROOT       = '/var/jenkins_home/minikube/ps2'
    MINIKUBE_HOME = "${MK_ROOT}/.minikube"
    KUBECONFIG    = "${MK_ROOT}/.kube/config"

    MK_DOCKER_NET = 'minikube-net'
    MK_SUBNET     = '10.123.0.0/16'
    MINIKUBE_IN_A_CONTAINER = 'true'
  }

  options { timestamps() }

  stages {
    stage('Checkout') {
      steps {
        cleanWs()
        git branch: 'main', url: 'https://github.com/KevinAntoun/430-Tutorial'
      }
    }

    stage('Install CLIs (once)') {
      steps {
        sh '''
          set -euo pipefail
          if [ "$(id -u)" -ne 0 ]; then
            echo "Install CLIs stage requires root privileges; run the Jenkins agent as root."
            exit 1
          fi
          if ! command -v minikube >/dev/null 2>&1; then
            curl -fsSL https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 -o /usr/local/bin/minikube
            chmod +x /usr/local/bin/minikube
          fi
          if ! command -v kubectl >/dev/null 2>&1; then
            KVER="$(curl -fsSL https://dl.k8s.io/release/stable.txt)"
            curl -fsSL "https://dl.k8s.io/release/${KVER}/bin/linux/amd64/kubectl" -o /usr/local/bin/kubectl
            chmod +x /usr/local/bin/kubectl
          fi
          apt-get update -y
          apt-get install -y --no-install-recommends iproute2 socat curl ca-certificates procps
          mkdir -p "${MINIKUBE_HOME}" "$(dirname "${KUBECONFIG}")"
        '''
      }
    }

    stage('Prepare dedicated Docker network for Minikube') {
      steps {
        sh '''
          set -euo pipefail
          if ! docker network inspect "${MK_DOCKER_NET}" >/dev/null 2>&1; then
            docker network create --driver=bridge --subnet="${MK_SUBNET}" "${MK_DOCKER_NET}"
          fi
        '''
      }
    }

    stage('Start or Re-use Minikube (race-free bridge, POSIX)') {
      steps {
        sh '''
          set -euo pipefail
          export NO_PROXY="127.0.0.1,localhost,.local,.svc,cluster.local,10.96.0.0/12,10.244.0.0/16,10.123.0.0/16"
          export no_proxy="${NO_PROXY}"
          unset HTTP_PROXY HTTPS_PROXY http_proxy https_proxy || true

          # --- background bridge loop (POSIX) ---
          cat > /tmp/minikube_port_bridge.sh <<'EOSH'
#!/usr/bin/env sh
set -eu
parse_host_port() { awk -F':' '{print $NF}'; }
while :; do
  PORT_MAPS="$(docker port minikube 2>/dev/null || true)"
  if [ -n "${PORT_MAPS}" ]; then
    echo "${PORT_MAPS}" | while IFS= read -r line; do
      [ -z "${line}" ] && continue
      HOST_PORT="$(echo "${line}" | parse_host_port)"
      case "${HOST_PORT}" in ''|*[!0-9]*) continue;; esac
      if ! ss -ltn 2>/dev/null | awk '{print $4}' | grep -q ":${HOST_PORT}\$"; then
        nohup socat TCP-LISTEN:${HOST_PORT},fork,reuseaddr TCP:host.docker.internal:${HOST_PORT} >/dev/null 2>&1 &
        echo "[BRIDGE] Forwarding container localhost:${HOST_PORT} -> host.docker.internal:${HOST_PORT}"
      fi
    done
  fi
  sleep 1
done
EOSH
          chmod +x /tmp/minikube_port_bridge.sh
          nohup /tmp/minikube_port_bridge.sh >/tmp/port-bridge.log 2>&1 &
          sleep 1

          # --- reuse or start cluster ---
          if minikube status -p minikube | grep -q Running; then
            echo "Reusing existing, running Minikube cluster."
            minikube -p minikube update-context
          else
            echo "Starting Minikube…"
            if ! minikube start -p minikube \
              --driver=docker \
              --container-runtime=containerd \
              --kubernetes-version=v1.30.0 \
              --cpus=2 --memory=4096 \
              --network="${MK_DOCKER_NET}" \
              --wait=all \
              --force \
              -v=3 --alsologtostderr; then
              echo "Start failed; deleting profile then retrying…"
              minikube delete -p minikube || true
              minikube start -p minikube \
                --driver=docker \
                --container-runtime=containerd \
                --kubernetes-version=v1.30.0 \
                --cpus=2 --memory=4096 \
                --network="${MK_DOCKER_NET}" \
                --wait=all \
                --force \
                -v=3 --alsologtostderr
            fi
          fi

          # --- explicit apiserver bridge + POSIX wait using socat as probe ---
          API_HOST_PORT="$(docker port minikube 8443/tcp | awk -F':' '{print $NF}' | tail -n1 || true)"
          case "${API_HOST_PORT}" in
            ''|*[!0-9]*)
              echo "[APISERVER] Could not determine host port from 'docker port minikube 8443/tcp'"
              docker port minikube || true
              ;;
            *)
              echo "[APISERVER] Host port is ${API_HOST_PORT}"
              if ! ss -ltn 2>/dev/null | awk '{print $4}' | grep -q ":${API_HOST_PORT}\$"; then
                nohup socat TCP-LISTEN:${API_HOST_PORT},fork,reuseaddr TCP:host.docker.internal:${API_HOST_PORT} >/dev/null 2>&1 &
                echo "[APISERVER] Dedicated forward started on :${API_HOST_PORT}"
              fi

              printf "[APISERVER] Waiting for localhost:%s " "${API_HOST_PORT}"
              i=0
              while ! socat - TCP:127.0.0.1:${API_HOST_PORT},connect-timeout=1 </dev/null >/dev/null 2>&1; do
                i=$((i+1)); [ "${i}" -ge 90 ] && { echo "TIMEOUT"; tail -n 100 /tmp/port-bridge.log || true; exit 1; }
                printf "."
                sleep 1
              done
              echo "OK"
              ;;
          esac

          echo "Verifying cluster connectivity..."
          kubectl config current-context
          kubectl get nodes -o wide
        '''
      }
    }

    stage('Compute Tag') {
      steps {
        script {
          env.TAG   = sh(returnStdout: true, script: 'git rev-parse --short HEAD').trim()
          env.IMAGE = "${env.APP}:${env.TAG}"
          echo "IMAGE=${env.IMAGE}"
        }
      }
    }

    stage('Build Docker Image (local)') {
      steps {
        dir(env.DOCKER_CTX) {
          sh 'docker build -t "${IMAGE}" .'
        }
      }
    }

    stage('Load Image into Minikube') {
      steps { sh 'minikube -p minikube image load "${IMAGE}"' }
    }

    stage('Apply Manifests & Rollout') {
      steps {
        sh """
          set -euo pipefail
          kubectl -n ${NS} apply -f ${MANIFEST_DIR}/deployment.yaml
          kubectl -n ${NS} apply -f ${MANIFEST_DIR}/service.yaml
          # ensure the deployment uses the fresh image
          kubectl -n ${NS} set image deploy/${DEPLOY} ${CTR}=${IMAGE}
          kubectl -n ${NS} rollout status deploy/${DEPLOY} --timeout=180s
          kubectl -n ${NS} get deploy,pods,svc -o wide
        """
      }
    }

    stage('Pods Snapshot & Debug') {
      steps {
        sh '''
          set -euo pipefail
          echo "== Context =="; kubectl config current-context || true
          echo "== All namespaces =="; kubectl get pods -A -o wide || true
          echo "== App namespace (${NS}) =="; kubectl -n ${NS} get deploy,po,svc,ep -o wide || true

          not_ready="$(kubectl -n ${NS} get pods --no-headers | awk '$2 != "1/1" || $3 != "Running" {print $1}')"
          if [ -n "${not_ready}" ]; then
            for p in ${not_ready}; do
              echo "---- describe $p ----"
              kubectl -n ${NS} describe pod "$p" || true
              echo "---- logs (all containers) $p ----"
              kubectl -n ${NS} logs --all-containers=true --prefix "$p" || true
            done
          fi
        '''
      }
    }

    stage('Make Interactive Access Easy (wrappers + helpers)') {
      steps {
        sh '''
          set -euo pipefail
          mkdir -p "${MINIKUBE_HOME}" "$(dirname "${KUBECONFIG}")"

          # kube-ps2
          cat > /usr/local/bin/kube-ps2 <<'EOS'
#!/usr/bin/env sh
export MK_ROOT="/var/jenkins_home/minikube/ps2"
export MINIKUBE_HOME="${MK_ROOT}/.minikube"
export KUBECONFIG="${MK_ROOT}/.kube/config"
unset HTTP_PROXY HTTPS_PROXY http_proxy https_proxy
export NO_PROXY='127.0.0.1,localhost,.local,.svc,cluster.local,10.96.0.0/12,10.244.0.0/16,10.123.0.0/16'
export no_proxy="${NO_PROXY}"
exec kubectl "$@"
EOS
          chmod +x /usr/local/bin/kube-ps2

          # mk-ps2
          cat > /usr/local/bin/mk-ps2 <<'EOS'
#!/usr/bin/env sh
export MK_ROOT="/var/jenkins_home/minikube/ps2"
export MINIKUBE_HOME="${MK_ROOT}/.minikube"
export KUBECONFIG="${MK_ROOT}/.kube/config"
unset HTTP_PROXY HTTPS_PROXY http_proxy https_proxy
export NO_PROXY='127.0.0.1,localhost,.local,.svc,cluster.local,10.96.0.0/12,10.244.0.0/16,10.123.0.0/16'
export no_proxy="${NO_PROXY}"
exec minikube -p minikube "$@"
EOS
          chmod +x /usr/local/bin/mk-ps2

          # start-ps2-bridge
          cat > /usr/local/bin/start-ps2-bridge <<'EOS'
#!/usr/bin/env sh
set -eu
if ! pgrep -f minikube_port_bridge.sh >/dev/null 2>&1; then
  nohup /tmp/minikube_port_bridge.sh >/tmp/port-bridge.log 2>&1 &
fi
API_HOST_PORT="$(docker port minikube 8443/tcp | awk -F':' '{print $NF}' | tail -n1 || true)"
case "${API_HOST_PORT}" in
  ''|*[!0-9]*) echo "Could not determine API host port"; docker port minikube || true; exit 0 ;;
  *)
    if ! ss -ltn 2>/dev/null | awk '{print $4}' | grep -q ":${API_HOST_PORT}\$"; then
      nohup socat TCP-LISTEN:${API_HOST_PORT},fork,reuseaddr TCP:host.docker.internal:${API_HOST_PORT} >/dev/null 2>&1 &
    fi
    i=0; while ! socat - TCP:127.0.0.1:${API_HOST_PORT},connect-timeout=1 </dev/null >/dev/null 2>&1; do
      i=$((i+1)); [ "$i" -ge 60 ] && break; sleep 1
    done
    echo "Bridge ready on :${API_HOST_PORT}"
    ;;
esac
EOS
          chmod +x /usr/local/bin/start-ps2-bridge

          # stop-ps2-bridge
          cat > /usr/local/bin/stop-ps2-bridge <<'EOS'
#!/usr/bin/env sh
pkill -f minikube_port_bridge.sh >/dev/null 2>&1 || true
pkill -f "socat TCP-LISTEN" >/dev/null 2>&1 || true
echo "Bridge stopped"
EOS
          chmod +x /usr/local/bin/stop-ps2-bridge

          # expose-django-service (minikube url helper for Windows)
          cat > /usr/local/bin/expose-django-service <<'EOS'
#!/usr/bin/env sh
set -eu
NS="${1:-default}"
SVC="${2:-django-service}"
: "${MK_DOCKER_NET:=minikube-net}"
: "${PS2_AGENT_CONTAINER_ID:=}"

fail() {
  echo "ERROR: $*" >&2
  exit 1
}

log() {
  echo "[expose] $*"
}

resolve_self_container() {
  set --
  if [ -n "${PS2_AGENT_CONTAINER_ID}" ]; then
    set -- "$@" "${PS2_AGENT_CONTAINER_ID}"
  fi
  h="$(hostname 2>/dev/null || true)"
  if [ -n "${h}" ]; then
    set -- "$@" "${h}"
  fi
  if [ -r /proc/self/cgroup ]; then
    cgroup_guess="$(grep -Eo '[0-9a-f]{64}' /proc/self/cgroup 2>/dev/null | head -n1)"
    if [ -n "${cgroup_guess}" ]; then
      set -- "$@" "${cgroup_guess}"
    fi
  fi
  if [ -r /proc/1/cpuset ]; then
    cpuset_guess="$(awk -F/ 'NF {print $NF}' /proc/1/cpuset 2>/dev/null)"
    if [ -n "${cpuset_guess}" ]; then
      set -- "$@" "${cpuset_guess}"
    fi
  fi
  for guess in "$@"; do
    [ -n "${guess}" ] || continue
    if docker inspect "${guess}" >/dev/null 2>&1; then
      docker inspect -f '{{.Id}}' "${guess}" 2>/dev/null && return 0
    fi
    cand="$(docker ps --no-trunc --filter "id=${guess}" --format '{{.ID}}' | head -n1)"
    if [ -n "${cand}" ]; then
      echo "${cand}"
      return 0
    fi
    cand="$(docker ps --filter "name=${guess}" --format '{{.ID}}' | head -n1)"
    if [ -n "${cand}" ]; then
      echo "${cand}"
      return 0
    fi
  done
  return 1
}

kube-ps2 -n "${NS}" get svc "${SVC}" >/dev/null 2>&1 || fail "Service ${NS}/${SVC} not found"

if ! docker network inspect "${MK_DOCKER_NET}" >/dev/null 2>&1; then
  fail "Docker network ${MK_DOCKER_NET} not found; run the Jenkins pipeline setup first."
fi

SELF_ID="$(resolve_self_container || true)"
[ -n "${SELF_ID}" ] || fail "Unable to determine the Jenkins container id; set PS2_AGENT_CONTAINER_ID explicitly if this job runs inside Docker."

if ! docker inspect "${SELF_ID}" >/dev/null 2>&1; then
  fail "Unable to inspect container ${SELF_ID}; ensure Docker access is available and PS2_AGENT_CONTAINER_ID is correct."
fi

attached="$(docker inspect -f '{{if index .NetworkSettings.Networks "'"${MK_DOCKER_NET}"'"}}yes{{end}}' "${SELF_ID}" 2>/dev/null || true)"
if [ "${attached}" != "yes" ]; then
  log "Attaching current container (${SELF_ID}) to ${MK_DOCKER_NET}"
  docker network connect "${MK_DOCKER_NET}" "${SELF_ID}" >/dev/null 2>&1 || true
fi

SELF_IP="$(docker inspect -f '{{with index .NetworkSettings.Networks "'"${MK_DOCKER_NET}"'"}}{{.IPAddress}}{{end}}' "${SELF_ID}" 2>/dev/null || true)"
if [ -z "${SELF_IP}" ]; then
  log "Attaching current container (${SELF_ID}) to ${MK_DOCKER_NET}"
  docker network connect "${MK_DOCKER_NET}" "${SELF_ID}" >/dev/null 2>&1 || true
  SELF_IP="$(docker inspect -f '{{with index .NetworkSettings.Networks "'"${MK_DOCKER_NET}"'"}}{{.IPAddress}}{{end}}' "${SELF_ID}" 2>/dev/null || true)"
fi
[ -n "${SELF_IP}" ] || fail "Container ${SELF_ID} has no IP on ${MK_DOCKER_NET}; connect it manually."

log "Fetching service URLs via minikube (timeout 120s)..."
set +e
MK_URLS_RAW="$(timeout 120 mk-ps2 service -n "${NS}" "${SVC}" --url 2>&1)"
MK_STATUS=$?
set -e
if [ "${MK_STATUS}" -ne 0 ]; then
  printf '%s\n' "${MK_URLS_RAW}" >&2
  if [ "${MK_STATUS}" -eq 124 ]; then
    fail "Timed out waiting for minikube to expose ${NS}/${SVC}; check pod readiness and NodePort."
  fi
  fail "minikube service --url failed; ensure the cluster and service are healthy."
fi
RAW_URLS="$(printf '%s\n' "${MK_URLS_RAW}" | tr -d '\r')"

if [ -z "$(printf '%s' "${RAW_URLS}" | tr -d '\n')" ]; then
  fail "minikube service --url returned no URLs for ${NS}/${SVC}"
fi

log "Removing stale Windows proxy containers for ${SVC}"
OLD_IFS="${IFS}"
IFS='
'
for cid in $(docker ps -a --filter "label=com.ps2.expose.service=${SVC}" --format '{{.ID}}'); do
  [ -n "${cid}" ] || continue
  docker rm -f "${cid}" >/dev/null 2>&1 || true
done
IFS="${OLD_IFS}"

log "minikube reported the following URLs:"
printf '%s\n' "${RAW_URLS}"

COUNT=0
WIN_URLS=""

while IFS= read -r url; do
  [ -n "${url}" ] || continue
  COUNT=$((COUNT + 1))

  proto_raw="${url%%://*}"
  if [ "${proto_raw}" = "${url}" ]; then
    proto_raw="http"
  fi
  proto="$(printf '%s' "${proto_raw}" | tr '[:upper:]' '[:lower:]')"

  rest="${url#*://}"
  host_port="${rest%%/*}"
  host="${host_port%%:*}"
  port="${host_port##*:}"
  if [ "${host}" = "${port}" ]; then
    port=""
  fi

  [ -n "${host}" ] || fail "Could not parse host from URL: ${url}"
  [ -n "${port}" ] || fail "Could not parse port from URL: ${url}"

  case "${host}" in
    127.0.0.1|localhost)
      target_host="${SELF_IP}"
      ;;
    *)
      target_host="${host}"
      ;;
  esac

  proxy_name="$(printf 'expose-%s-%s-%s' "${SVC}" "${proto}" "${port}")"
  docker rm -f "${proxy_name}" >/dev/null 2>&1 || true

  if ! docker run -d --name "${proxy_name}" \
      --network "${MK_DOCKER_NET}" \
      --restart unless-stopped \
      --label com.ps2.expose=1 \
      --label com.ps2.expose.service="${SVC}" \
      --label com.ps2.expose.port="${port}" \
      -p 127.0.0.1::"${port}" \
      alpine/socat \
      TCP-LISTEN:"${port}",fork,reuseaddr,bind=0.0.0.0 TCP:"${target_host}":"${port}" >/dev/null 2>&1; then
    fail "Failed to start proxy container ${proxy_name}"
  fi

  host_port="$(docker port "${proxy_name}" "${port}/tcp" | awk -F':' 'NF==2 {print $2}' | tail -n1)"
  [ -n "${host_port}" ] || fail "Could not determine published host port for ${proxy_name}"

  windows_url="$(printf '%s://127.0.0.1:%s' "${proto}" "${host_port}")"
  WIN_URLS="${WIN_URLS}${windows_url}\n"
  log "Mapped ${url} -> ${windows_url} (proxy ${proxy_name})"
done <<EOF
${RAW_URLS}
EOF

[ "${COUNT}" -gt 0 ] || fail "minikube service --url produced no usable entries"

printf '\nWindows-friendly URLs now reachable on this machine:\n'
printf '%b' "${WIN_URLS}"
printf 'To tear them down later: docker ps --filter "label=com.ps2.expose.service=%s" -q | xargs docker rm -f\n' "${SVC}"
EOS
          chmod +x /usr/local/bin/expose-django-service

          echo "Installed: kube-ps2, mk-ps2, start-ps2-bridge, stop-ps2-bridge, expose-django-service"
        '''
      }
    }

    // Optional: print the Windows-friendly URL
    stage('Expose Django URL (print for Windows)') {
      steps {
        sh '''
          set -euo pipefail
          start-ps2-bridge
          echo "Discovering a Windows-friendly URL for django-service..."
          expose-django-service default django-service
        '''
      }
    }

    stage('Archive K8s Snapshot') {
      steps {
        sh '''
          set -euo pipefail
          mkdir -p k8s-dump
          kubectl config view --minify > k8s-dump/kubeconfig-view.txt || true
          kubectl -n ${NS} get deploy,po,rs,svc,ep -o wide > k8s-dump/resources.txt || true
          kubectl -n ${NS} get events --sort-by=.lastTimestamp > k8s-dump/events.txt || true
        '''
        archiveArtifacts artifacts: 'k8s-dump/**', allowEmptyArchive: true
      }
    }
  }

  post {
    always {
      echo 'Pipeline finished.'
    }
    failure {
      echo 'Collecting Minikube & network logs for debugging…'
      sh 'minikube -p minikube logs --file=logs.txt || true'
      archiveArtifacts artifacts: 'logs.txt', allowEmptyArchive: true
      sh 'docker network ls || true'
      sh 'docker network inspect "${MK_DOCKER_NET}" || true'
      sh 'echo "[BRIDGE LOGS]"; tail -n 200 /tmp/port-bridge.log || true'
    }
  }
}
