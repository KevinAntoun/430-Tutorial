pipeline {
  agent any

  triggers { pollSCM('H/2 * * * *') }

  environment {
    NS            = 'default'
    APP           = 'mydjangoapp'
    DEPLOY        = 'django-deployment'
    CTR           = 'django-container'
    DOCKER_CTX    = 'ps2'
    MANIFEST_DIR  = 'ps2'

    MK_ROOT       = '/var/jenkins_home/minikube/ps2'
    MINIKUBE_HOME = "${MK_ROOT}/.minikube"
    KUBECONFIG    = "${MK_ROOT}/.kube/config"

    MK_DOCKER_NET = 'minikube-net'
    MK_SUBNET     = '10.123.0.0/16'
    MINIKUBE_IN_A_CONTAINER = 'true'
  }

  options { timestamps() }

  stages {
    stage('Checkout') {
      steps {
        cleanWs()
        git branch: 'main', url: 'https://github.com/KevinAntoun/430-Tutorial'
      }
    }

    stage('Install CLIs (once)') {
      steps {
        sh '''
          set -euo pipefail
          if [ "$(id -u)" -ne 0 ]; then
            echo "Install CLIs stage requires root privileges; run the Jenkins agent as root."
            exit 1
          fi
          if ! command -v minikube >/dev/null 2>&1; then
            curl -fsSL https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 -o /usr/local/bin/minikube
            chmod +x /usr/local/bin/minikube
          fi
          if ! command -v kubectl >/dev/null 2>&1; then
            KVER="$(curl -fsSL https://dl.k8s.io/release/stable.txt)"
            curl -fsSL "https://dl.k8s.io/release/${KVER}/bin/linux/amd64/kubectl" -o /usr/local/bin/kubectl
            chmod +x /usr/local/bin/kubectl
          fi
          apt-get update -y
          # ADDED: jq for robust JSON parsing
          apt-get install -y --no-install-recommends iproute2 socat curl ca-certificates procps jq
          mkdir -p "${MINIKUBE_HOME}" "$(dirname "${KUBECONFIG}")"
        '''
      }
    }

    stage('Prepare dedicated Docker network for Minikube') {
      steps {
        sh '''
          set -euo pipefail
          if ! docker network inspect "${MK_DOCKER_NET}" >/dev.null 2>&1; then
            docker network create --driver=bridge --subnet="${MK_SUBNET}" "${MK_DOCKER_NET}"
          fi
        '''
      }
    }

    stage('Start or Re-use Minikube (race-free bridge, POSIX)') {
      steps {
        sh '''
          set -euo pipefail
          export NO_PROXY="127.0.0.1,localhost,.local,.svc,cluster.local,10.96.0.0/12,10.244.0.0/16,10.123.0.0/16"
          export no_proxy="${NO_PROXY}"
          unset HTTP_PROXY HTTPS_PROXY http_proxy https_proxy || true

          # --- background bridge loop (POSIX) ---
          cat > /tmp/minikube_port_bridge.sh <<'EOSH'
#!/usr/bin/env sh
set -eu
parse_host_port() { awk -F':' '{print $NF}'; }
while :; do
  PORT_MAPS="$(docker port minikube 2>/dev/null || true)"
  if [ -n "${PORT_MAPS}" ]; then
    echo "${PORT_MAPS}" | while IFS= read -r line; do
      [ -z "${line}" ] && continue
      HOST_PORT="$(echo "${line}" | parse_host_port)"
      case "${HOST_PORT}" in ''|*[!0-9]*) continue;; esac
      if ! ss -ltn 2>/dev/null | awk '{print $4}' | grep -q ":${HOST_PORT}\$"; then
        nohup socat TCP-LISTEN:${HOST_PORT},fork,reuseaddr TCP:host.docker.internal:${HOST_PORT} >/dev/null 2>&1 &
        echo "[BRIDGE] Forwarding container localhost:${HOST_PORT} -> host.docker.internal:${HOST_PORT}"
      fi
    done
  fi
  sleep 1
done
EOSH
          chmod +x /tmp/minikube_port_bridge.sh
          nohup /tmp/minikube_port_bridge.sh >/tmp/port-bridge.log 2>&1 &
          sleep 1

          # --- reuse or start cluster ---
          if minikube status -p minikube | grep -q Running; then
            echo "Reusing existing, running Minikube cluster."
            minikube -p minikube update-context
          else
            echo "Starting Minikube…"
            if ! minikube start -p minikube \
              --driver=docker \
              --container-runtime=containerd \
              --kubernetes-version=v1.30.0 \
              --cpus=2 --memory=4096 \
              --network="${MK_DOCKER_NET}" \
              --wait=all \
              --force \
              -v=3 --alsologtostderr; then
              echo "Start failed; deleting profile then retrying…"
              minikube delete -p minikube || true
              minikube start -p minikube \
                --driver=docker \
                --container-runtime=containerd \
                --kubernetes-version=v1.30.0 \
                --cpus=2 --memory=4096 \
                --network="${MK_DOCKER_NET}" \
                --wait=all \
                --force \
                -v=3 --alsologtostderr
            fi
          fi

          # --- explicit apiserver bridge + POSIX wait using socat as probe ---
          API_HOST_PORT="$(docker port minikube 8443/tcp | awk -F':' '{print $NF}' | tail -n1 || true)"
          case "${API_HOST_PORT}" in
            ''|*[!0-9]*)
              echo "[APISERVER] Could not determine host port from 'docker port minikube 8443/tcp'"
              docker port minikube || true
              ;;
            *)
              echo "[APISERVER] Host port is ${API_HOST_PORT}"
              if ! ss -ltn 2>/dev/null | awk '{print $4}' | grep -q ":${API_HOST_PORT}\$"; then
                nohup socat TCP-LISTEN:${API_HOST_PORT},fork,reuseaddr TCP:host.docker.internal:${API_HOST_PORT} >/dev/null 2>&1 &
                echo "[APISERVER] Dedicated forward started on :${API_HOST_PORT}"
              fi

              printf "[APISERVER] Waiting for localhost:%s " "${API_HOST_PORT}"
              i=0
              while ! socat - TCP:127.0.0.1:${API_HOST_PORT},connect-timeout=1 </dev/null >/dev/null 2>&1; do
                i=$((i+1)); [ "${i}" -ge 90 ] && { echo "TIMEOUT"; tail -n 100 /tmp/port-bridge.log || true; exit 1; }
                printf "."
                sleep 1
              done
              echo "OK"
              ;;
          esac

          echo "Verifying cluster connectivity..."
          kubectl config current-context
          kubectl get nodes -o wide
        '''
      }
    }

    stage('Compute Tag') {
      steps {
        script {
          env.TAG   = sh(returnStdout: true, script: 'git rev-parse --short HEAD').trim()
          env.IMAGE = "${env.APP}:${env.TAG}"
          echo "IMAGE=${env.IMAGE}"
        }
      }
    }

    stage('Build Docker Image (local)') {
      steps {
        dir(env.DOCKER_CTX) {
          sh 'docker build -t "${IMAGE}" .'
        }
      }
    }

    stage('Load Image into Minikube') {
      steps { sh 'minikube -p minikube image load "${IMAGE}"' }
    }

    stage('Apply Manifests & Rollout') {
      steps {
        sh """
          set -euo pipefail
          kubectl -n ${NS} apply -f ${MANIFEST_DIR}/deployment.yaml
          kubectl -n ${NS} apply -f ${MANIFEST_DIR}/service.yaml
          # ensure the deployment uses the fresh image
          kubectl -n ${NS} set image deploy/${DEPLOY} ${CTR}=${IMAGE}
          kubectl -n ${NS} rollout status deploy/${DEPLOY} --timeout=180s
          kubectl -n ${NS} get deploy,pods,svc -o wide
        """
      }
    }

    stage('Pods Snapshot & Debug') {
      steps {
        sh '''
          set -euo pipefail
          echo "== Context =="; kubectl config current-context || true
          echo "== All namespaces =="; kubectl get pods -A -o wide || true
          echo "== App namespace (${NS}) =="; kubectl -n ${NS} get deploy,po,svc,ep -o wide || true

          not_ready="$(kubectl -n ${NS} get pods --no-headers | awk '$2 != "1/1" || $3 != "Running" {print $1}')"
          if [ -n "${not_ready}" ]; then
            for p in ${not_ready}; do
              echo "---- describe $p ----"
              kubectl -n ${NS} describe pod "$p" || true
              echo "---- logs (all containers) $p ----"
              kubectl -n ${NS} logs --all-containers=true --prefix "$p" || true
            done
          fi
        '''
      }
    }

    stage('Make Interactive Access Easy (wrappers + helpers)') {
      steps {
        sh '''
          set -euo pipefail
          mkdir -p "${MINIKUBE_HOME}" "$(dirname "${KUBECONFIG}")"

          # kube-ps2
          cat > /usr/local/bin/kube-ps2 <<'EOS'
#!/usr/bin/env sh
export MK_ROOT="/var/jenkins_home/minikube/ps2"
export MINIKUBE_HOME="${MK_ROOT}/.minikube"
export KUBECONFIG="${MK_ROOT}/.kube/config"
unset HTTP_PROXY HTTPS_PROXY http_proxy https_proxy
export NO_PROXY='127.0.0.1,localhost,.local,.svc,cluster.local,10.96.0.0/12,10.244.0.0/16,10.123.0.0/16'
export no_proxy="${NO_PROXY}"
exec kubectl "$@"
EOS
          chmod +x /usr/local/bin/kube-ps2

          # mk-ps2
          cat > /usr/local/bin/mk-ps2 <<'EOS'
#!/usr/bin/env sh
export MK_ROOT="/var/jenkins_home/minikube/ps2"
export MINIKUBE_HOME="${MK_ROOT}/.minikube"
export KUBECONFIG="${MK_ROOT}/.kube/config"
unset HTTP_PROXY HTTPS_PROXY http_proxy https_proxy
export NO_PROXY='127.0.0.1,localhost,.local,.svc,cluster.local,10.96.0.0/12,10.244.0.0/16,10.123.0.0/16'
export no_proxy="${NO_PROXY}"
exec minikube -p minikube "$@"
EOS
          chmod +x /usr/local/bin/mk-ps2

          # start-ps2-bridge
          cat > /usr/local/bin/start-ps2-bridge <<'EOS'
#!/usr/bin/env sh
set -eu
if ! pgrep -f minikube_port_bridge.sh >/dev/null 2>&1; then
  nohup /tmp/minikube_port_bridge.sh >/tmp/port-bridge.log 2>&1 &
fi
API_HOST_PORT="$(docker port minikube 8443/tcp | awk -F':' '{print $NF}' | tail -n1 || true)"
case "${API_HOST_PORT}" in
  ''|*[!0-9]*) echo "Could not determine API host port"; docker port minikube || true; exit 0 ;;
  *)
    if ! ss -ltn 2>/dev/null | awk '{print $4}' | grep -q ":${API_HOST_PORT}\$"; then
      nohup socat TCP-LISTEN:${API_HOST_PORT},fork,reuseaddr TCP:host.docker.internal:${API_HOST_PORT} >/dev/null 2>&1 &
    fi
    i=0; while ! socat - TCP:127.0.0.1:${API_HOST_PORT},connect-timeout=1 </dev/null >/dev/null 2>&1; do
      i=$((i+1)); [ "$i" -ge 60 ] && break; sleep 1
    done
    echo "Bridge ready on :${API_HOST_PORT}"
    ;;
esac
EOS
          chmod +x /usr/local/bin/start-ps2-bridge

          # stop-ps2-bridge
          cat > /usr/local/bin/stop-ps2-bridge <<'EOS'
#!/usr/bin/env sh
pkill -f minikube_port_bridge.sh >/dev/null 2>&1 || true
pkill -f "socat TCP-LISTEN" >/dev/null 2>&1 || true
echo "Bridge stopped"
EOS
          chmod +x /usr/local/bin/stop-ps2-bridge

          # expose-django-service (NodePort targeting + port-forward fallback, using jq)
          cat > /usr/local/bin/expose-django-service <<'EOS'
#!/usr/bin/env sh
set -eu

NS="${1:-default}"
SVC="${2:-django-service}"
: "${MK_DOCKER_NET:=minikube-net}"
: "${PS2_AGENT_CONTAINER_ID:=}"

fail() { echo "ERROR: $*" >&2; exit 1; }
log()  { echo "[expose] $*"; }

# --- helpers to resolve Jenkins container id/ip on MK_DOCKER_NET ---
resolve_self_container() {
  set --
  if [ -n "${PS2_AGENT_CONTAINER_ID}" ]; then set -- "$@" "${PS2_AGENT_CONTAINER_ID}"; fi
  h="$(hostname 2>/dev/null || true)"; [ -n "${h}" ] && set -- "$@" "${h}"
  if [ -r /proc/self/cgroup ]; then
    cgroup_guess="$(grep -Eo '[0-9a-f]{64}' /proc/self/cgroup 2>/dev/null | head -n1)"
    [ -n "${cgroup_guess}" ] && set -- "$@" "${cgroup_guess}"
  fi
  if [ -r /proc/1/cpuset ]; then
    cpuset_guess="$(awk -F/ 'NF {print $NF}' /proc/1/cpuset 2>/dev/null)"
    [ -n "${cpuset_guess}" ] && set -- "$@" "${cpuset_guess}"
  fi
  for guess in "$@"; do
    [ -z "${guess}" ] && continue
    if docker inspect "${guess}" >/dev/null 2>&1; then docker inspect -f '{{.Id}}' "${guess}" && return 0; fi
    cand="$(docker ps --no-trunc --filter "id=${guess}" --format '{{.ID}}' | head -n1)"; [ -n "${cand}" ] && { echo "${cand}"; return 0; }
    cand="$(docker ps --filter "name=${guess}" --format '{{.ID}}' | head -n1)"; [ -n "${cand}" ] && { echo "${cand}"; return 0; }
  done
  return 1
}

# --- prechecks ---
kube-ps2 -n "${NS}" get svc "${SVC}" >/dev/null 2>&1 || fail "Service ${NS}/${SVC} not found"
docker network inspect "${MK_DOCKER_NET}" >/dev/null 2>&1 || fail "Docker network ${MK_DOCKER_NET} not found"

SELF_ID="$(resolve_self_container || true)"; [ -n "${SELF_ID}" ] || fail "Unable to determine the Jenkins container id"
docker inspect "${SELF_ID}" >/dev/null 2>&1 || fail "Unable to inspect container ${SELF_ID}"

attached="$(docker inspect -f '{{if index .NetworkSettings.Networks "'"${MK_DOCKER_NET}"'"}}yes{{end}}' "${SELF_ID}" 2>/dev/null || true)"
if [ "${attached}" != "yes" ]; then
  log "Attaching current container (${SELF_ID}) to ${MK_DOCKER_NET}"
  docker network connect "${MK_DOCKER_NET}" "${SELF_ID}" >/dev/null 2>&1 || true
fi

SELF_IP="$(docker inspect -f '{{with index .NetworkSettings.Networks "'"${MK_DOCKER_NET}"'"}}{{.IPAddress}}{{end}}' "${SELF_ID}" 2>/dev/null || true)"
[ -n "${SELF_IP}" ] || fail "Container ${SELF_ID} has no IP on ${MK_DOCKER_NET}"

TYPE="$(kube-ps2 -n "${NS}" get svc "${SVC}" -o jsonpath='{.spec.type}')"

# Robust port map via jq: lines of "servicePort:nodePort" (nodePort empty if not applicable)
PORTMAP="$(
  kube-ps2 -n "${NS}" get svc "${SVC}" -o json \
  | jq -r '.spec.ports[] | (.port|tostring)+":" + ((.nodePort // "")|tostring)'
)"

NODE_IP="$(mk-ps2 ip)"

get_nodeport_for() {
  svc_port="$1"
  echo "$PORTMAP" | awk -f: -v p="$svc_port" '$1==p && $2!="" {print $2; exit}'
}

ensure_pf_for() {
  local local_p="$1" target_p="$2"
  if ! ss -ltn 2>/dev/null | awk '{print $4}' | grep -q ":$local_p$"; then
    nohup kube-ps2 -n "${NS}" port-forward "svc/${SVC}" --address=0.0.0.0 "${local_p}:${target_p}" >/tmp/pf-"${SVC}"-"${local_p}".log 2>&1 &
    for i in $(seq 1 60); do ss -ltn 2>/dev/null | awk '{print $4}' | grep -q ":$local_p$" && break || sleep 0.2; done
  fi
}

log "Fetching service URLs via minikube (timeout 120s)..."
set +e
MK_URLS_RAW="$(timeout 120 mk-ps2 service -n "${NS}" "${SVC}" --url 2>&1)"
MK_STATUS=$?
set -e
RAW_URLS="$(printf '%s\n' "${MK_URLS_RAW}" | tr -d '\r')"
URL_LINES="$(printf '%s\n' "${RAW_URLS}" | awk 'index($0,"://")')"

if [ "${MK_STATUS}" -ne 0 ]; then
  stripped="$(printf '%s' "${URL_LINES}" | tr -d '\n')"
  if [ "${MK_STATUS}" -eq 124 ] && [ -n "${stripped}" ]; then
    log "minikube service --url timed out after emitting URLs; continuing with captured output."
  else
    printf '%s\n' "${MK_URLS_RAW}" >&2
    fail "minikube service --url failed (exit ${MK_STATUS}); ensure the cluster and service are healthy."
  fi
fi
[ -n "$(printf '%s' "${URL_LINES}" | tr -d '\n')" ] || { printf '%s\n' "${RAW_URLS}" >&2; fail "minikube service --url returned no URLs for ${NS}/${SVC}"; }

log "Removing stale proxy containers for ${SVC}"
OLD_IFS="${IFS}"; IFS='
'
for cid in $(docker ps -a --filter "label=com.ps2.expose.service=${SVC}" --format '{{.ID}}'); do
  [ -n "${cid}" ] && docker rm -f "${cid}" >/dev/null 2>&1 || true
done
IFS="${OLD_IFS}"

log "minikube reported the following URLs:"
printf '%s\n' "${URL_LINES}"

COUNT=0
WIN_URLS=""

while IFS= read -r url; do
  [ -n "${url}" ] || continue
  COUNT=$((COUNT + 1))

  proto_raw="${url%%://*}"; [ "${proto_raw}" = "${url}" ] && proto_raw="http"
  proto="$(printf '%s' "${proto_raw}" | tr '[:upper:]' '[:lower:]')"

  rest="${url#*://}"; host_port="${rest%%/*}"
  host="${host_port%%:*}"; port="${host_port##*:}"
  [ "${host}" = "${port}" ] && port=""

  [ -n "${host}" ] || fail "Could not parse host from URL: ${url}"
  [ -n "${port}" ] || fail "Could not parse port from URL: ${url}"

  svc_port="${port}"  # servicePort typically equals URL port

  TARGET_HOST=""; TARGET_PORT=""
  if [ "${host}" = "127.0.0.1" ] || [ "${host}" = "localhost" ]; then
    if [ "${TYPE}" = "NodePort" ]; then
      node_p="$(get_nodeport_for "${svc_port}")"
      if [ -n "${node_p}" ]; then
        TARGET_HOST="${NODE_IP}"
        TARGET_PORT="${node_p}"
      else
        TARGET_HOST="${SELF_IP}"
        TARGET_PORT="${svc_port}"
        ensure_pf_for "${TARGET_PORT}" "${svc_port}"
      fi
    else
      TARGET_HOST="${SELF_IP}"
      TARGET_PORT="${svc_port}"
      ensure_pf_for "${TARGET_PORT}" "${svc_port}"
    fi
  else
    TARGET_HOST="${host}"
    TARGET_PORT="${port}"
  fi

  proxy_name="$(printf 'expose-%s-%s-%s' "${SVC}" "${proto}" "${TARGET_PORT}")"
  docker rm -f "${proxy_name}" >/dev/null 2>&1 || true

  if ! docker run -d --name "${proxy_name}" \
      --network "${MK_DOCKER_NET}" \
      --restart unless-stopped \
      --label com.ps2.expose=1 \
      --label com.ps2.expose.service="${SVC}" \
      --label com.ps2.expose.port="${TARGET_PORT}" \
      -p 127.0.0.1::"${TARGET_PORT}" \
      alpine/socat \
      TCP-LISTEN:"${TARGET_PORT}",fork,reuseaddr,bind=0.0.0.0 TCP:"${TARGET_HOST}":"${TARGET_PORT}" >/dev/null 2>&1; then
    fail "Failed to start proxy container ${proxy_name}"
  fi

  host_port="$(docker port "${proxy_name}" "${TARGET_PORT}/tcp" | awk -F: 'NF==2 {print $2}' | tail -n1)"
  [ -n "${host_port}" ] || fail "Could not determine published host port for ${proxy_name}"

  windows_url="$(printf '%s://127.0.0.1:%s' "${proto}" "${host_port}")"
  WIN_URLS="${WIN_URLS}${windows_url}    (from ${url})\n"
  log "Mapped ${url} -> ${windows_url} (proxy ${proxy_name} -> ${TARGET_HOST}:${TARGET_PORT})"
done <<EOF
${URL_LINES}
EOF

[ "${COUNT}" -gt 0 ] || fail "No usable URLs produced"

printf '\nWindows-friendly URLs now reachable on this machine:\n'
printf '%b' "${WIN_URLS}"
printf 'To tear them down later: docker ps --filter "label=com.ps2.expose.service=%s" -q | xargs -r docker rm -f\n' "${SVC}"
EOS
          chmod +x /usr/local/bin/expose-django-service

          echo "Installed: kube-ps2, mk-ps2, start-ps2-bridge, stop-ps2-bridge, expose-django-service"
        '''
      }
    }

    // Optional: print the Windows-friendly URL(s)
    stage('Expose Django URL (print for Windows)') {
      steps {
        sh '''
          set -euo pipefail
          start-ps2-bridge
          echo "Discovering Windows-friendly URLs for django-service..."
          expose-django-service default django-service
        '''
      }
    }

    stage('Archive K8s Snapshot') {
      steps {
        sh '''
          set -euo pipefail
          mkdir -p k8s-dump
          kubectl config view --minify > k8s-dump/kubeconfig-view.txt || true
          kubectl -n ${NS} get deploy,po,rs,svc,ep -o wide > k8s-dump/resources.txt || true
          kubectl -n ${NS} get events --sort-by=.lastTimestamp > k8s-dump/events.txt || true
        '''
        archiveArtifacts artifacts: 'k8s-dump/**', allowEmptyArchive: true
      }
    }
  }

  post {
    always {
      echo 'Pipeline finished.'
    }
    failure {
      echo 'Collecting Minikube & network logs for debugging…'
      sh 'minikube -p minikube logs --file=logs.txt || true'
      archiveArtifacts artifacts: 'logs.txt', allowEmptyArchive: true
      sh 'docker network ls || true'
      sh 'docker network inspect "${MK_DOCKER_NET}" || true'
      sh 'echo "[BRIDGE LOGS]"; tail -n 200 /tmp/port-bridge.log || true'
    }
  }
}
