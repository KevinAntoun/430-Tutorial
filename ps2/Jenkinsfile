pipeline {
  agent any

  triggers {
    // poll every 2 minutes
    pollSCM('H/2 * * * *')
  }

  environment {
    NS            = 'default'
    APP           = 'mydjangoapp'
    DEPLOY        = 'django-deployment'   // metadata.name in deployment.yaml
    CTR           = 'web'                 // containers[].name in deployment.yaml
    DOCKER_CTX    = 'ps2'                 // path containing Dockerfile
    MANIFEST_DIR  = 'ps2'                 // path containing deployment.yaml/service.yaml

    // Persist cluster config/state across stages in this workspace
    MINIKUBE_HOME = "${WORKSPACE}/.minikube"
    KUBECONFIG    = "${WORKSPACE}/.kube/config"

    // Dedicated Docker network for Minikube
    MK_DOCKER_NET = 'minikube-net'
    MK_SUBNET     = '10.123.0.0/16'

    // We are running Minikube inside a container
    MINIKUBE_IN_A_CONTAINER = 'true'
  }

  options {
    timestamps()
  }

  stages {

    stage('Checkout') {
      steps {
        cleanWs()
        git branch: 'main', url: 'https://github.com/KevinAntoun/430-Tutorial'
      }
    }

    stage('Install CLIs (once)') {
      steps {
        sh '''
          set -euo pipefail

          # --- Minikube ---
          if ! command -v minikube >/dev/null 2>&1; then
            curl -fsSL https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 -o /usr/local/bin/minikube
            chmod +x /usr/local/bin/minikube
          fi
          minikube version || true

          # --- kubectl ---
          if ! command -v kubectl >/dev/null 2>&1; then
            KVER="$(curl -fsSL https://dl.k8s.io/release/stable.txt)"
            curl -fsSL "https://dl.k8s.io/release/${KVER}/bin/linux/amd64/kubectl" -o /usr/local/bin/kubectl
            chmod +x /usr/local/bin/kubectl
          fi

          # ensure dirs for kube/minikube live under workspace
          mkdir -p "${MINIKUBE_HOME}" "$(dirname "${KUBECONFIG}")"
        '''
      }
    }

    stage('Prepare dedicated Docker network for Minikube') {
      steps {
        sh '''
          set -euo pipefail

          if docker network inspect "${MK_DOCKER_NET}" >/dev/null 2>&1; then
            echo "Using existing Docker network: ${MK_DOCKER_NET}"
          else
            echo "Creating Docker network: ${MK_DOCKER_NET} (${MK_SUBNET})"
            if ! docker network create --driver=bridge --subnet="${MK_SUBNET}" "${MK_DOCKER_NET}"; then
              echo "ERROR: Failed to create ${MK_DOCKER_NET} on ${MK_SUBNET} (likely subnet conflict)."
              echo "Existing networks:"
              docker network ls
              echo "Details:"
              docker network ls -q | xargs -r docker network inspect -f '{{.Name}} {{range .IPAM.Config}}{{.Subnet}}{{end}}'
              exit 2
            fi
          fi

          docker network inspect "${MK_DOCKER_NET}" -f '{{.Name}} {{range .IPAM.Config}}{{.Subnet}}{{end}}'
        '''
      }
    }

    stage('Start Minikube (with localhost SSH bridge)') {
      steps {
        sh '''
          set -euo pipefail

          # Clean any old/broken Minikube profile
          minikube -p minikube delete || true

          # If a leftover Docker network named "minikube" exists AND is empty, remove it.
          if docker network inspect minikube >/dev/null 2>&1; then
            CONTAINERS_JSON="$(docker network inspect minikube -f '{{json .Containers}}' || echo '{}')"
            if [ "${CONTAINERS_JSON}" = "{}" ]; then
              echo "Removing stale empty Docker network 'minikube' to avoid IP conflicts..."
              docker network rm minikube || true
            else
              echo "Docker network 'minikube' has attached containers; leaving it in place."
            fi
          fi

          # Make sure the default 'minikube' docker network isn't lingering
          if docker network inspect minikube >/dev/null 2>&1; then
            docker network rm minikube || true
          fi

          # --- Ensure socat is available (for SSH bridge) ---
          if ! command -v socat >/dev/null 2>&1; then
            # debian-based Jenkins
            apt-get update -y && apt-get install -y --no-install-recommends socat || true
          fi

          # --- Launch SSH localhost bridge in background ---
          # This bridges 127.0.0.1:<host_ssh_port> inside the Jenkins container
          # to host.docker.internal:<host_ssh_port> so minikube's localhost SSH works.
          cat > /tmp/minikube_ssh_bridge.sh <<'EOSH'
#!/usr/bin/env bash
set -euo pipefail
BRIDGED_PORT=""
while true; do
  HP="$(docker container inspect -f '{{range $p,$v := .NetworkSettings.Ports}}{{if eq $p "22/tcp"}}{{(index $v 0).HostPort}}{{end}}{{end}}' minikube 2>/dev/null || true)"
  if [[ -n "${HP:-}" ]]; then
    if [[ "${HP}" != "${BRIDGED_PORT:-}" ]]; then
      pkill -f "socat TCP-LISTEN:${BRIDGED_PORT}," >/dev/null 2>&1 || true
      # Listen on container-local loopback and forward to Docker host's published port
      nohup socat TCP-LISTEN:${HP},fork,reuseaddr TCP:host.docker.internal:${HP} >/tmp/socat-${HP}.log 2>&1 &
      BRIDGED_PORT="${HP}"
      echo "Bridging 127.0.0.1:${HP} -> host.docker.internal:${HP}"
    fi
  fi
  sleep 1
done
EOSH
          chmod +x /tmp/minikube_ssh_bridge.sh
          nohup /tmp/minikube_ssh_bridge.sh >/tmp/ssh-bridge.log 2>&1 &

          # --- Start Minikube on our dedicated Docker network ---
          # --listen-address=0.0.0.0 ensures host publishes ports on 0.0.0.0 (so host.docker.internal can reach them)
          minikube start -p minikube \
            --driver=docker \
            --container-runtime=containerd \
            --kubernetes-version=v1.30.0 \
            --cpus=2 --memory=4096 \
            --network="${MK_DOCKER_NET}" \
            --preload=false \
            --delete-on-failure \
            --wait=all \
            --force \
            --listen-address=0.0.0.0 \
            -v=3 --alsologtostderr

          kubectl config current-context
          kubectl get nodes -o wide
        '''
      }
    }

    stage('Compute Tag') {
      steps {
        script {
          env.TAG   = sh(returnStdout: true, script: 'git rev-parse --short HEAD').trim()
          env.IMAGE = "${env.APP}:${env.TAG}"   // local tag; loaded into minikube
          echo "IMAGE=${env.IMAGE}"
        }
      }
    }

    stage('Build Docker Image (local)') {
      steps {
        dir(env.DOCKER_CTX) {
          sh '''
            set -euo pipefail
            docker build -t '"'"${IMAGE}"'"' .
          '''
        }
      }
    }

    stage('Load Image into Minikube') {
      steps {
        sh '''
          set -euo pipefail
          minikube -p minikube image load '"'"${IMAGE}"'"'
          # Optional: confirm it inside containerd on the node
          minikube -p minikube ssh -- "ctr -n=k8s.io images ls | grep ${APP} || true"
        '''
      }
    }

    stage('Apply Manifests & Rollout') {
      steps {
        sh """
          set -euo pipefail

          kubectl -n ${NS} apply -f ${MANIFEST_DIR}/deployment.yaml
          kubectl -n ${NS} apply -f ${MANIFEST_DIR}/service.yaml

          kubectl -n ${NS} set image deploy/${DEPLOY} ${CTR}=${IMAGE}

          kubectl -n ${NS} rollout status deploy/${DEPLOY} --timeout=180s

          kubectl -n ${NS} get deploy ${DEPLOY} -o wide
          kubectl -n ${NS} get pods -o wide
          kubectl -n ${NS} get svc
        """
      }
    }
  }

  post {
    always {
      echo "Pipeline finished (success or failure)."
      # best-effort cleanup of ssh bridge
      sh 'pkill -f minikube_ssh_bridge.sh || true'
      sh 'pkill -f "socat TCP-LISTEN" || true'
    }
    failure {
      echo "Collecting Minikube & network logs for debuggingâ€¦"
      sh 'minikube -p minikube logs --file=logs.txt || true'
      archiveArtifacts artifacts: 'logs.txt', onlyIfSuccessful: false, allowEmptyArchive: true
      sh 'docker network ls || true'
      sh 'docker network inspect "${MK_DOCKER_NET}" || true'
    }
  }
}
