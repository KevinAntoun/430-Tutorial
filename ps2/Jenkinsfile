pipeline {
  agent any

  triggers {
    pollSCM('H/2 * * * *') // every 2 minutes
  }

  environment {
    NS           = 'default'
    APP          = 'mydjangoapp'
    DEPLOY       = 'django-deployment'
    CTR          = 'web'
    DOCKER_CTX   = 'ps2'
    MANIFEST_DIR = 'ps2'

    // Make minikube + kubeconfig live in the workspace (persist across steps)
    MINIKUBE_HOME = "${WORKSPACE}/.minikube"
    KUBECONFIG    = "${WORKSPACE}/.kube/config"
  }

  stages {
    stage('Checkout') {
      steps {
        cleanWs()
        git branch: 'main', url: 'https://github.com/KevinAntoun/430-Tutorial'
      }
    }

    stage('Install CLIs (once)') {
      steps {
        sh '''
          set -euo pipefail

          # minikube
          if ! command -v minikube >/dev/null 2>&1; then
            curl -fsSL https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 -o /usr/local/bin/minikube
            chmod +x /usr/local/bin/minikube
          fi
          minikube version || true

          # kubectl
          if ! command -v kubectl >/dev/null 2>&1; then
            KVER="$(curl -fsSL https://dl.k8s.io/release/stable.txt)"
            curl -fsSL "https://dl.k8s.io/release/${KVER}/bin/linux/amd64/kubectl" -o /usr/local/bin/kubectl
            chmod +x /usr/local/bin/kubectl
          fi

          mkdir -p "${MINIKUBE_HOME}" "$(dirname "${KUBECONFIG}")"
        '''
      }
    }

    stage('Start Minikube (once per workspace)') {
      steps {
        sh '''
          set -euo pipefail
          # If cluster isn't up, start it
          if ! minikube -p minikube status >/dev/null 2>&1; then
            minikube start -p minikube \
              --driver=docker \
              --container-runtime=containerd \
              --kubernetes-version=stable
          fi

          # Show node to confirm connectivity
          kubectl get nodes -o wide
          kubectl config current-context
        '''
      }
    }

    stage('Compute Tag') {
      steps {
        script {
          env.TAG   = sh(returnStdout: true, script: 'git rev-parse --short HEAD').trim()
          env.IMAGE = "${env.APP}:${env.TAG}"
          echo "IMAGE=${env.IMAGE}"
        }
      }
    }

    stage('Build Docker Image (local)') {
      steps {
        dir(env.DOCKER_CTX) {
          sh "docker build -t ${IMAGE} ."
        }
      }
    }

    stage('Load Image into Minikube') {
      steps {
        sh '''
          set -euo pipefail
          # Load local image into the Minikube nodeâ€™s runtime
          minikube -p minikube image load '"'"${IMAGE}"'"'
          # (Optional) verify image now exists inside the node
          minikube -p minikube ssh -- "ctr -n=k8s.io images ls | grep ${APP} || true"
        '''
      }
    }

    stage('Apply Manifests & Rollout') {
      steps {
        sh """
          set -euo pipefail
          kubectl -n ${NS} apply -f ${MANIFEST_DIR}/deployment.yaml
          kubectl -n ${NS} apply -f ${MANIFEST_DIR}/service.yaml

          # Ensure the Deployment points to our freshly loaded image tag
          kubectl -n ${NS} set image deploy/${DEPLOY} ${CTR}=${IMAGE}

          kubectl -n ${NS} rollout status deploy/${DEPLOY} --timeout=180s
          kubectl -n ${NS} get deploy ${DEPLOY} -o wide
          kubectl -n ${NS} get pods -o wide
          kubectl -n ${NS} get svc
        """
      }
    }
  }
}
